<!doctype html>
<head>
    <title>Logic Gates and Boolean Algebra</title>
    <meta name="Igor" content="Logic Gates and Boolean Algebra">
        <link rel="stylesheet" type="text/css" href="style.css">
            <!--[if IE]>
             <style>* {
             font-family: "comic sans MS"!important;
             } </style>
             <![endif]-->
</head>

<body>
    <header>
        <div id="div">
            <h1>Computing Revision Guide</h1>
            
            <h2>Chapter 7.1 Logic Gates and Boolean Algebra</h2>
        </div>
        <nav>
            <ul>
                <a href="logicgates.html"><li id="chosen"><span>Chapter 7.1</span> <span>Logic Gates and Boolean Algebra</span></li></a>
              <a href="computerarchitecture.html"><li><span>Chapter 7.2</span> <span>Computer Architecture</span></li></a>
              <a href="machinecode.html"><li><span>Chapter 7.3</span> <span>Machine Code Operations and the Fetch-Execute Cycle</span></li></a>
              <a><li><span>Chapter 8.1</span> <span>Hardware Devices</span></li></a>
              <a href="classificationofsoftware.html"><li><span>Chapter 8.2</span> <span>Classification of Software</span></li></a>
              <a href="structureoftheinternet.html"><li><span>Chapter 9.1</span> <span>Structure of the Internet</span></li></a>
              <a><li><span>Chapter 10.1</span> <span>Legal and Ethical Issues</span></li></a>
            </ul>
        </nav>
    </header>
    
    <section id="content">
        <h1>Table of Contents</h1>
        <section id="contents">
            <ol>
                <li><a href="#Basics">Boolean Algebra Basics</a></li>
                <li><a href="#Laws">Boolean Algebra Laws</a></li>
                <li><a href="#Simplify">Simplifying Boolean Expressions</a></li>
                <li><a href="#Logic">Logic Gates</a></li>
            </ol>
        </section>
        
        
        <section id="Basics" class="line">
            <h3>Boolean Algebra Basics</h3>
            <p> In mathematics and mathematical logic, Boolean algebra is the subarea of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 respectively. Instead of elementary algebra where the values of the variables are numbers, and the main operations are addition and multiplication, the main operations of Boolean algebra are the conjunction AND, denoted ., the disjunction OR, denoted +, and the negation not, denoted &#8254;. </p>
            
            <p> To demonstrate the behaviour of Boolean functions (operations of Boolean algebra), we can construct truth tables: tables that show the results of applying the logical function to all possible combinations of inputs. They are typically structured as:
            
            <table border="1">
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>Q</th>
                </tr>
                <tr>
                    <td>0 (Value of A)</td>
                    <td>0 (Value of B)</td>
                    <td>0 (Output of boolean function)</td>
                </tr>
                <tr>
                    <td>0 (Value of A)</td>
                    <td>1 (Value of B)</td>
                    <td>1 (Output of boolean function)</td>
                </tr>
                <tr>
                    <td>1 (Value of A)</td>
                    <td>0 (Value of B)</td>
                    <td>1 (Output of boolean function)</td>
                </tr>
                <tr>
                    <td>1 (Value of A)</td>
                    <td>1 (Value of B)</td>
                    <td>1 (Output of boolean function)</td>
                </tr>
            </table>
            
            
            <p> The main boolean functions that you will come accross are described below:</p>
            <h4> OR/+ function </h4>
            <p> If X and Y are Boolean variables, A OR B is written as A + B. If A + B = Q, Q is true if either A, B or both are true and false otherwise.</p>
            Truth table for OR:
            <table border="1">
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>Q</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
            </table>
            
            
            <h4> AND/. function </h4>
            <p> If A and B are Boolean variables, A AND B is written as A.B. If A.B = Q, Q is true if both A and B are true and false otherwise. AND has greater precedense than OR.</p>
            Truth table for AND:
            <table border="1">
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>Q</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
            </table>
            
            <h4> NOT/&#8254; function </h4>
            <p> If A is a Boolean variable, NOT A is written as <N>A</N>. If <N>A</N> = Q, Q is true if A is false and false otherwise. </p>
            Truth table for NOT:
            <table border="1">
                <tr>
                    <th>A</th>
                    <th>Q</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                </tr>
                
            </table>
            
            <h4> XOR/&#8853; function </h4>
            <p> If A and B are Boolean variables, A XOR B is written as A&#8853;B. If A&#8853;B = Q, Q is true if either (not both) A or B is true and false otherwise.</p>
            Truth table for XOR:
            <table border="1">
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>Q</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
            </table>
            
            <h4> NAND/&#8593; function </h4>
            <p> If A and B are Boolean variables, A NAND B is written as A&#8593;B. If A&#8593;B = Q, Q is true if A and B are false and false otherwise.</p>
            Truth table for XOR:
            <table border="1">
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>Q</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
            </table>
            
            <h4> NOR/&#8595; function </h4>
            <p> If A and B are Boolean variables, A NOR B is written as A&#8595;B. If A&#8595;B = Q, Q is true if A and B are false and false otherwise.</p>
            Truth table for XOR:
            <table border="1">
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>Q</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1</td>
                    <td>0</td>
                </tr>
            </table>
            <br>
        </section>
        
        <section id="Laws" class="line">
            <h3> Boolean Algebra Laws </h3>
            <p> A law of Boolean algebra is an identity such as x.(y.z) = (x.y).z between two Boolean terms, where a Boolean term is defined as an expression built up from boolean variables and the constants 0 and 1 using the operations +, . and &#8254; (here the terms are x.(y.z) and (x.y).z). Those laws define the algebra and are outlined below:
            
            <h4> Main Identities </h4>
            
            <ul>
                <li>A + B = B + A</li>
                <li>(A + B) + C = A + (B + C)</li>
                <li>A.B = B.A</li>
                <li>A.(B.C) = (A.B).C</li>
                <li>A.(B + C) = A.B + A.C</li>
                <li>A.A = A</li>
                <li>A.<N>A</N> = 0</li>
                <li>A + 1 = 1</li>
                <li>A + 0 = A</li>
                <li>A + A = A</li>
                <li>A + <N>A</N> = 1</li>
                <li>A.0 = 0</li>
                <li>A.1 = A</li>
                <li>A + A.B = A (*)</li>
                <li>A + <N>A</N>.B = A + B (**)</li>
            </ul>
            
            <h4> De Morgan's Laws </h4>
            <p>
            In propositional logic and boolean algebra, De Morgan's laws are a pair of transformation rules that allow the expression of AND and OR purely in terms of each other via negation:
            </p>
            <ul>
                <li>A + B + C + D + ... = <NN><N>A</N>.<N>B</N>.<N>C</N>.<N>D</N>....<NN></li>
                <li>A.B.C.D.... = <NN><N>A</N> + <N>B</N> + <N>C</N> + <N>D</N> + ...</NN></li>
            </ul>
            
            Applications of the rules include simplification of logical expressions in computer programs and digital circuit designs.
            
            <div style="display: table-row">
                <div style="width:400px; display: table-cell;"> <h4>(*) Derivation of A + A.B = A:</h4>
                    <p><em> Using A.1 = A </em></p>
                    A + A.B =  A.1 + A.B
                    <p><em> Using A.(B + C) = A.B + A.C </em></p>
                    A.1 + A.B = A.(1 + B)
                    <p><em> Using A + 1 = 1 </em></p>
                    A.(1 + B) = A.1
                    <p><em> Using A.1 = A </em></p>
                    A.1 = A </div>
                <div style="display: table-cell;"> <h4>(**) Derivation of A + <N>A</N>.B = A + B:</h4>
                    <p><em> Using A + A.B = A </em></p>
                    A + <N>A</N>.B = A + A.B + <N>A</N>.B
                    <p><em> Using A.(B + C) = A.B + A.C </em></p>
                    A + A.B + <N>A</N>.B = A + B.(A + <N>A</N>)
                    <p><em> Using A + <N>A</N> = 1 </em></p>
                    A + B.(A + <N>A</N>) = A + B.1
                    <p><em> Using A.1 = A </em></p>
                    <p>A + B.1 = A + B</p> </div>
            </div>
        </section>
        
        <section id="Simplify" class="line">
            <h3>Simplifying Boolean Expressions </h3>
            
            <p>In an exam you will often be asked to simplify a boolean expression. This means that you need to reduce the expression using valid identities to one which would produce the same truth table as the original but which uses the smallest possible number of variables and operations. This can be done either by hand or using a Karnaugh map. Both approaches will be outlined below:</p>
            
            <h4>"By hand" method:</h4>
            <p>
            Simplifying a boolean expression by hand requires you to utilise boolean identities to find elements of the expression that could be stated with fewer variables/operations. Below are a couple of examples of how this is done:</p>
            
            <div style="display: table-row">
                <div style="width:400px; display: table-cell;"> <h4>Simplify (A+B).(A+A)</h4>
                    <p><em>Using A.(B + C) = A.B + A.C</em></p>
                    (A+B).(A+A) = A.A + B.A + A.A + B.A
                    <p><em>Using A + A = A</em></p>
                    A.A + B.A + A.A + B.A = A.A + A.B
                    <p><em>Using A.A = A</em></p>
                    A.A + A.B = A + A.B
                    <p><em>Using A + A.B = A</em></p>
                    A + A.B = A </div>
                <div style="display: table-cell;"> <h4>Simplify (A.<N>B</N>)+(A.B)</h4>
                    <p><em>Using the fact that AND has greater precedence than OR</em></p>
                    (A.<N>B</N>)+(A.B) = A.<N>B</N>+A.B
                    <p><em>Using A.(B + C) = A.B + A.C</em></p>
                    A.<N>B</N>+A.B = A.(B + <N>B</N>)
                    <p><em>Using A + <N>A</N> = 1</em></p>
                    A.(B + <N>B</N>) = A.1
                    <p><em>Using A.1 = A</em></p>
                    <p>A.1 = A</p> </div>
            </div>
            
            
            
            
            <h4>Karnaugh Map:</h4>
            <p>A karnaugh map is a two-way truth table, possible combinations of inputs along the top and along the side. We will look at Karnaugh maps for 4 variables, but the principles discussed can be extended for greater or smaller numbers.</p>
            <p>To use a Karnaugh map, draw a grid like below:</p>
            <img src="img/Map1.png" alt="Empty Karnaugh">
                <p> Then fill the grid like you would a truth table - the value of each square is the value of your boolean expression if the corresponding values of A, B, C and D are substituted into it (for any given square, the values of A and B to use are the two numbers along the top for that square and for C and D - along the side. A is the left number, B the right, C the bottom, D the top: same as the in the labels).</p>
                
                <p> Now try to draw  a set of rectangles whose area (in squares) must be a power of two and which together must contain all the squares in which you placed a 1 and none of the ones with a zero. Example:</p>
                <img src="img/Map2.png" alt="Empty Karnaugh">
                    <p> If you now express each rectangle as a product of boolean variables (possible negated with NOT) and add up the products for all the rectangles, you will obtain the simplified version of your expression. For the rectangle above:</p>
                    The red rectangle can be expressed as A.<N>C</N>, the green as A.<N>B</N> and the blue as B.C.<N>D</N>. Hence the simplified expression is A.<N>C</N> + A.<N>B</N> + B.C.<N>D</N>.
                    
                    <p> Below are some questions for you to try. Try by hand first and then use a Karnaugh map if you're stuck. Expand the views to see the step-by-step answers. </p>
                    
                    <details>
                        <summary> Show that <NN>(<N>A</N> + B).(A + <N>B</N>)</NN> = (A + B).(<N>A</N> + <N>B</N>)  </summary>
                        <p><em> Using A.(B + C) = A.B + A.C </em></p>
                        <p><NN>(<N>A</N> + B).(A + <N>B</N>)</NN> = <NN><N>A</N>.A + A.B + <N>A</N>.<N>B</N> + <N>B</N>.B</NN> </p>
                        <p><em> Using A.A = 0 </em></p>
                        <p><NN><N>A</N>.A + A.B + <N>A</N>.<N>B</N> + <N>B</N>.B</NN> = <NN>A.B + <N>A</N>.<N>B</N></NN> </p>
                        <p><em> Using De Morgan's Law 2. </em></p>
                        <p> <NN>A.B + <N>A</N>.<N>B</N></NN> = <NNN><NN>(<N>A</N> + <N>B</N>)</NN> + <N> (A + B) </N></NNN> </p>
                        <p><em> Using De Morgan's Law 2. and A.B = B.A </em></p>
                        <p> <NNN><NN>(<N>A</N> + <N>B</N>)</NN> + <N> (A + B) </N></NNN> = (A + B).(<N>A</N> + <N>B</N>)</p>
                    </details>
                    
                    <details>
                        <summary> Simplify A.B.C + <N>C</N>(D + A.B) + D(<N>A</N> + <N>C</N>)  </summary>
                        <p><em> Using A.(B + C) = A.B + A.C</em></p>
                        <p>A.B.C + <N>C</N>(D + A.B) + D(<N>A</N> + <N>C</N>) = A.B.C + <N>C</N>.D + A.B.<N>C</N> + <N>A</N>.D + <N>C</N>.D</p>
                        <p><em> Using A.(B + C) = A.B + A.C, A + <N>A</N> = 1, A + A = A </em></p>
                        <p>A.B.C + <N>C</N>.D + A.B.<N>C</N> + <N>A</N>.D + <N>C</N>.D = A.B + <N>C</N>.D + <N>A</N>.D</p>
                        <p> Answer: A.B + <N>C</N>.D + <N>A</N>.D </p>
                    </details>
                    
                    <details>
                        <summary> Simplify A.B.C.D + <N>A</N>.<N>B</N>.C.<N>D</N> + A.<N>B</N>.<N>C</N>.<N>D</N> + <N>A</N>.B.<N>C</N>.<N>D</N> + A.B.C.<N>D</N>  </summary>
                        <p><em> Using A.(B + C) = A.B + A.C, A + A = 1, A + A = A</em></p>
                        <p>A.B.C.D + <N>A</N>.<N>B</N>.C.<N>D</N> + A.<N>B</N>.<N>C</N>.<N>D</N> + <N>A</N>.B.<N>C</N>.<N>D</N> + A.B.C.<N>D</N> = A.B.C + <N>A</N>.<N>B</N>.C.<N>D</N> + A.<N>B</N>.<N>C</N>.<N>D</N> + <N>A</N>.B.<N>C</N>.<N>D</N></p>
                        <p> Answer: A.B.C + <N>A</N>.<N>B</N>.C.<N>D</N> + A.<N>B</N>.<N>C</N>.<N>D</N> + <N>A</N>.B.<N>C</N>.<N>D</N> </p>
                    </details>
                    
                    
                    <details>
                        <summary> Simplify A.(B + C.D) + B.(<N>A</N>.<N>C</N>.D) + C.(A.<N>B</N>.<N>D</N>) + D.(A + B.<N>C</N>)  </summary>
                        <p><em> Using A.(B + C) = A.B + A.C</em></p>
                        <p>A.(B + C.D) + B.(<N>A</N>.<N>C</N>.D) + C.(A.<N>B</N>.<N>D</N>) + D.(A + B.<N>C</N>) = A.B + A.C.D + <N>A</N>.B.<N>C</N>.D + A.<N>B</N>.C.<N>D</N> + A.D + B.<N>C</N>.D</p>
                        <p><em> Using A + A.B = A</em></p>
                        <p>A.B + A.C.D + <N>A</N>.B.<N>C</N>.D + A.<N>B</N>.C.<N>D</N> + A.D + B.<N>C</N>.D = A.B + A.<N>B</N>.C.<N>D</N> + A.D + B.<N>C</N>.D</p>
                        <p><em> Using A + A.B = A, A.(B + C) = A.B + A.C and De Morgan's Law 2.</em></p>
                        <p>A.B + A.<N>B</N>.C.<N>D</N> + A.D + B.<N>C</N>.D = A.B + A.D + A.C.(A + B) + A.C.(<N>B + D</N>) + B.<N>C</N>.D</p>
                        <p><em> Using A + A.B = A </em></p>
                        <p>A.B + A.D + A.C.(A + B) + A.C.(<N>B + D</N>) + B.<N>C</N>.D = A.B + A.C + A.D + B.<N>C</N>.D</p>
                        <p> Answer: A.B + A.C + A.D + B.<N>C</N>.D </p>
                    </details>
                    
                    
                    <details>
                        <summary> Simplify (A + B).(<N>C</N> + D) + (A + C).(<N>B</N>.<N>D</N>) + (B + <N>C</N>).(<N>A</N>.D) </summary>
                        <p><em>Using A.(B + C) = A.B + A.C</em></p>
                        <p>(A + B).(<N>C</N> + D) + (A + C).(<N>B</N>.<N>D</N>) + (B + <N>C</N>).(<N>A</N>.D) = A.<N>C</N> + B.<N>C</N> + A.D + B.D + A.<N>B</N>.<N>D</N> + <N>B</N>.C.<N>D</N> + <N>A</N>.B.D + <N>A</N>.<N>C</N>.D</p>
                        <p><em>Using A + B = B + A and A + A.B = A</em></p>
                        <p>A.<N>C</N> + B.<N>C</N> + A.D + B.D + A.<N>B</N>.<N>D</N> + <N>B</N>.C.<N>D</N> + <N>A</N>.B.D + <N>A</N>.<N>C</N>.D = B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.B.D + A.<N>B</N>.D + A.<N>B</N>.<N>D</N> + A.<N>C</N> + <N>A</N>.B.D + <N>A</N>.<N>C</N>.D</p>
                        <p><em>Using A + A.B = A</em></p>
                        <p>B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.B.D + A.<N>B</N>.D + A.<N>B</N>.<N>D</N> + A.<N>C</N> + <N>A</N>.B.D + <N>A</N>.<N>C</N>.D = B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + A.<N>C</N> + <N>A</N>.<N>C</N>.D</p>
                        <p><em>Using A + A.B = A</em></p>
                        <p>B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + A.<N>C</N> + <N>A</N>.<N>C</N>.D = B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + A.<N>C</N>B + A.<N>C</N>.<N>B</N> + <N>A</N>.<N>C</N>.D</p>
                        <p><em>Using A + A.B = A</em></p>
                        <p>B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + A.<N>C</N>B + A.<N>C</N>.<N>B</N> + <N>A</N>.<N>C</N>.D = B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + <N>A</N>.<N>C</N>.D</p>
                        <p><em>Using A + A.B = A</em></p>
                        <p>B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + <N>A</N>.<N>C</N>.D = B.<N>C</N> + A.B.<N>C</N>.D + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + A.<N>B</N>.<N>C</N>.D + <N>A</N>.<N>C</N>.D</p>
                        <p><em>Using A + A.B = A</em></p>
                        <p>B.<N>C</N> + A.B.<N>C</N>.D + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + A.<N>B</N>.<N>C</N>.D + <N>A</N>.<N>C</N>.D = B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + A.<N>C</N>.D + <N>A</N>.<N>C</N>.D</p>
                        <p><em>Using A + A.B = A</em></p>
                        <p>B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + A.<N>C</N>.D + <N>A</N>.<N>C</N>.D = B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + <N>C</N>.D</p>
                        <p> Answer: B.<N>C</N> + B.D + <N>B</N>.C.<N>D</N> + A.<N>B</N> + <N>C</N>.D </p>
                    </details>
                    <p> &zwnj; </p>
        </section>
        
        <section id="Logic" class="line">
            <h3>Logic Gates </h3>
            <p> Logic Gates are electronic circuits that perform a boolean function. Logic gates are primarily implemented using diodes or transistors acting as electronic switches, but can also be constructed using vacuum tubes, electromagnetic relays and a variety of other technologies. The main logic gates are outlined below and an example of a logic gate built on transistors is displayed at the bottom of this section:</p>
            
            
            <h4> OR Gate </h4>
            <p> Performs the OR function on the inputs and outputs the result (on the image, the inputs are on the left and the output on the right)</p>
            Symbol for OR Gate:
            <img src="img/OR.png" alt="OR Gate" height="50" width="120">
                
                
                <h4> AND Gate </h4>
                <p> Performs the AND function on the inputs and outputs the result (on the image, the inputs are on the left and the output on the right)</p>
                Symbol for AND Gate:
                <img src="img/AND.png" alt="AND Gate" height="50" width="120">
                    
                    
                    <h4> NOT Gate </h4>
                    <p> Performs the NOT function on the input and outputs the result (on the image, the input is on the left and the output on the right)</p>
                    Symbol for NOT Gate:
                    <img src="img/NOT.png" alt="NOT Gate" height="50" width="120">
                        
                        
                        <h4> XOR Gate </h4>
                        <p> Performs the XOR function on the inputs and outputs the result (on the image, the inputs are on the left and the output on the right)</p>
                        Symbol for XOR Gate:
                        <img src="img/XOR.png" alt="XOR Gate" height="50" width="120">
                            
                            
                            <h4> NAND Gate </h4>
                            <p> Performs the NAND function on the inputs and outputs the result (on the image, the inputs are on the left and the output on the right)</p>
                            Symbol for NAND Gate:
                            <img src="img/NAND.png" alt="NAND Gate" height="50" width="120">
                                
                                
                                <h4> NOR Logic Gate </h4>
                                <p> Performs the NOR function on the inputs and outputs the result (on the image, the inputs are on the left and the output on the right)</p>
                                Symbol for NOR Gate:
                                <img src="img/NOR.png" alt="OR Logic Gate" height="50" width="120">
                                    
                                    
                                    <h4> NOT using NAND Gate </h4>
                                    <p> A NOT Gate can be built from a NAND gate by sending one input signal to both inputs</p>
                                    Symbol for a NOT Gate made from a NAND Gate:
                                    <img src="img/NOTNAND.png" alt="NAND Gate" height="50" width="120">
                                        
                                        
                                        <h4> NOT using NOR Gate </h4>
                                        <p> A NOT Gate can be built from a NOR gate by sending one input signal to both inputs</p>
                                        Symbol for a NOT Gate made from a NOR Gate:
                                        <img src="img/NOTNOR.png" alt="NAND Gate" height="50" width="120">
                                            
                                            
                                            
                                            <p>Logic Gates are commonly built from transistors. For the AND Gate, the transistors are in series and both transistors must be in the conducting state (their inputs must be 'true') to drive the output high (output 'true'). Further information about the internal workings of logic gates can be found by following the HyperPhysics link. </p>
                                            <p>Schematic for a transitor-based AND Gate:</p>
                                            
                                            <img src="img/ANDTRANS.png" alt="AND Gate using transistors">
        </section>
    </section>
</body>

</html>

